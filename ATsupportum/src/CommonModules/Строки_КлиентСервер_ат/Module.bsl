
////////////////////////////////////////////////////////////////////////////////
// Работа со строками
// 
// Первый автор - Вячеслав 'Mechanist' А. Павлов (с) с 2008 г.
//
//////////////////////////////////////////////////////////////////////////////// 


// Возвращает обрезанную строку Стр с конца на КоличествоСимволов.
// Реализация: Возврат Left(Стр, StrLen(Стр) - КоличествоСимволов);
Функция   ВернутьОбрезаннуюСтроку(Знач Стр, КоличествоСимволов) Экспорт
	
	Возврат Лев(Стр, СтрДлина(Стр) - КоличествоСимволов);
	
КонецФункции

// Обрезает строку Стр с начала на КоличествоСимволов и возвращает вырезанную часть.
// Реализация: Стр = Лев(Стр, КоличествоСимволов); Возврат Mid(Стр, КоличествоСимволов + 1);
Функция   ВырезатьСтрокуСлева(Стр, КоличествоСимволов) Экспорт
	
	Стр2 = Left(Стр, КоличествоСимволов);
	Стр = Mid(Стр, КоличествоСимволов + 1);
	Возврат Стр2;
	
КонецФункции

// Обрезает строку Стр с конца на КоличествоСимволов и возвращает вырезанную часть.
// Реализация: Стр = Лев(Стр, StrLen(Стр) - КоличествоСимволов); Возврат Right(Стр, КоличествоСимволов);
Функция   ВырезатьСтрокуСправа(Стр, КоличествоСимволов) Экспорт
	
	Стр2 = Right(Стр, КоличествоСимволов);
	Стр = Left(Стр, StrLen(Стр) - КоличествоСимволов);
	Возврат Стр2;
	
КонецФункции

// Возвращает вырезанную часть длиной КоличествоСимволов из строки Стр начиная с символа с индексом НачПозиция.
// Реализация: 	Возврат Mid(Стр, НачПозиция, КоличествоСимволов);
// 				Стр = Left(Стр, НачПозиция - 1) + Mid(Стр, НачПозиция + КоличествоСимволов);
Функция   ВырезатьСтроку(Стр, НачПозиция, КоличествоСимволов) Экспорт
	
	Стр2 = Mid(Стр, НачПозиция, КоличествоСимволов);
	Стр = Left(Стр, НачПозиция - 1) + Mid(Стр, НачПозиция + КоличествоСимволов);
	Возврат Стр2;
	
КонецФункции

// Возвращает вырезанную часть из строки Стр начиная с символа с индексом НачПозиция и заканчивая (включительно)
// символом с индексом КонПозиция.
// Реализация: 	Возврат Mid(Стр, НачПозиция, КонПозиция + 1 - НачПозиция);
// 				Стр = Left(Стр, НачПозиция - 1) + Mid(Стр, КонПозиция + 1);
Функция   ВырезатьСтрокуПо(Стр, НачПозиция, КонПозиция) Экспорт
	
	Стр2 = Mid(Стр, НачПозиция, КонПозиция + 1 - НачПозиция);
	Стр = Left(Стр, НачПозиция - 1) + Mid(Стр, КонПозиция + 1);
	Возврат Стр2;
	
КонецФункции

Функция   ВернутьДополненнуюСтроку(Знач Стр, Длина, Паттерн, СНачала = Ложь) Экспорт
	
	ЦелыхПаттернов = Окр((Длина - СтрДлина(Стр)) / СтрДлина(Паттерн));
	Для КолвоПовторов = 1 По ЦелыхПаттернов Цикл
		Если СНачала Тогда
			Стр = Паттерн + Стр;
		Иначе
			Стр = Стр + Паттерн;
		КонецЕсли;
	КонецЦикла;
	
	Если СНачала Тогда
		Возврат Прав(Паттерн, Длина - СтрДлина(Стр)) + Стр;
	Иначе
		Возврат Стр + Лев(Паттерн, Длина - СтрДлина(Стр));
	КонецЕсли;
	
КонецФункции // СтрДополнить

// Возвращает NumIncl-ное вхождение SubStr в участок строки Str определяемый индексами BegPos и EndPos.
//
// Эти параметры могут принимать значения по умолчанию -1 и/или 0, а также указывать реальные индексы симвлов в строке Str.
// Правила подстановки:
// 	1.	-1 - начало строки
// 	2.	 0 - конец строки
//  3.	если BegPos или EndPos больше, чем длина строки Str, то значение параметра приравнивается к ее длине
// 	4.	при значении EndPos большего, чем EndPos участок будет просматриваться с конца в обратном порядке
// Примеры:
//  	BegPos 		EndPos  Функция осуществляет просмотр:
//  		-1 			-1 	только первого символа (особенность алгоритма),
//  		-1 			0 	с начала строки до конца строки,
//  		0 			-1  от конца строки к началу строки в обратном порядке,
//  		0 			0 	только последнего символа (особенность алгоритма),
//  		-1			X 	с начала строки до X-ного символа,
//  		X 			-1 	от X-ного символа к началу строки в обратном порядке,
//  		0			X 	от конца строки к X-ному символу в обратном порядке,
//  		X 			0 	с X-ного символа до конца строки.
//			X1 			X2 	с X1-ого символа до X2-ого (при условии X1 < X2), и
//							с X2-ого символа до X1-ого в обратном порядке (при условии X1 > X2)
// Вне зависимости от значения этих параметров и направления просмотра, возвращаемый индекс всегда отсчитывается с начала
// передаваемой в Str строки.
//
// Параметр UseSepInclOnly определяет режим поиска n-ого включения.
// В случае его равенства True каждое следующее включение будет учитываться только в случае его невложенности в (n-1)-ое:
//                        12345789 <- индекс символа
//  SubStr = 'aba' Str = 'abababab'
//  UseSepInclOnly = True  => result = 2 (позиции включений = 1, 5)
//  UseSepInclOnly = False => result = 3 (позиции включений = 1, 3, 5).
//
// При NumIncl = 1 или Length(SubSt) = 1 этот параметр не имеет значения.
//
// Данная функция является конвертацией аналогичной из моей библиотеки под Delphi, посему принято решение о её
// анголязычности ;)
function  НайтиПозициюПодстроки(val Str, val SubStr, CaseSensitive = false, BegPos = -1, EndPos = 0, val NumIncl = 1, UseSepInclOnly = false) export // СтрНайти
	
	LenStr = StrLen(Str);
	LenSubStr = StrLen(SubStr);
	
	if (NumIncl <= 0) or (LenSubStr > LenStr) or (LenStr = 0) or (LenSubStr = 0) then
		return 0;
	endif;
	
	if (BegPos < 0) then
		BegPos_ = 1;
	elsif (BegPos = 0) or (BegPos > LenStr) then
		BegPos_ = LenStr;
	else
		BegPos_ = BegPos;
	endif;
	
	if (EndPos < 0) then
		EndPos_ = 1;
	elsif (EndPos = 0) or (EndPos > LenStr) then
		EndPos_ = LenStr;
	else
		EndPos_ = EndPos;
	endif;
	
	if ((BegPos_ <= EndPos_) and (LenSubStr > EndPos_ - BegPos_ + 1)) or
	    ((BegPos_ >= EndPos_) and (LenSubStr > BegPos_ - EndPos_ + 1)) then
		return 0;
	endif;
	
	if (BegPos_ <= EndPos_) then
		Str2 = Mid(Str, BegPos_, EndPos_ - BegPos_ + 1);
		SubStr2 = SubStr;
	else
	    Str2 = ВернутьПеревернутуюСтроку(Mid(Str, EndPos_, BegPos_ - EndPos_ + 1));
	    SubStr2 = ВернутьПеревернутуюСтроку(SubStr);
	endif;
	
	if not CaseSensitive then
		Str2 = Lower(Str2);
		SubStr2 = Lower(SubStr2);
	endif;
	
	PosInStr = 0;
	CurPos = Find(Str2, SubStr2);
	while CurPos > 0 do
		PosInStr = PosInStr + CurPos;
		NumIncl = NumIncl - 1;
		
		if NumIncl = 0 then
			if (BegPos_ <= EndPos_) then
				return PosInStr + BegPos_ - 1;
			else
				return BegPos_ - PosInStr - LenSubStr + 2; //- упрощенная формула от EndPos_-1+(BegPos_-EndPos_+1-PosInStr-LenSubStr+2)
			endif;
		else
			if UseSepInclOnly then
				Str2 = Left(Str2, CurPos + LenSubStr - 1);
			else
				Str2 = Left(Str2, CurPos);
			endif;
		endif;
		
		CurPos = Find(Str2, SubStr2);
	enddo;
	
	return 0;
	
//SELFTEST:	
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, -1, 0));
//6
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, 0, -1));
//11
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, 0, 400));
//0
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, 400, 0));
//0
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, 400, -1));
//11
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, 7, 0));
//11
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, 7, -1));
//6
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, 7, 12));
//11
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, 12, 7));
//11
//сообщить(стрнайти("фывАПРолдЖрО", "Ро",, 12, 0));
//0
//сообщить(стрнайти("фывАПРолдЖрО", "о",, 0, 0));
//12
//сообщить(стрнайти("фывАПРолдЖрО", "Ф",, -1, -1));
//1

endfunction // НайтиПозициюПодстроки

// Возвращает перевернутую строку.
// Пример: "asdfg" -> "gfdsa"
Функция   ВернутьПеревернутуюСтроку(Знач Стр) Экспорт
	
	Стр2 = "";
	Для i = 1 По StrLen(Стр) Цикл
		Стр2 = Сред(Стр, i, 1) + Стр2;
	КонецЦикла;
	
	Возврат Стр2;
	
КонецФункции

Функция   ВернутьСтрокуСБольшойПервойБуквы(Знач Стр) Экспорт
	
	Возврат ВРег(Лев(Стр, 1)) + Сред(Стр, 2);
	
КонецФункции

// Возвращает символ Стр[Индекс] в верхнем регистре.
// Реализация: Возврат ВРег(Сред(Стр, Индекс, 1));
Функция   ВернутьСимволВРег(Знач Стр, Индекс) Экспорт
	
	Возврат ВРег(Сред(Стр, Индекс, 1));
	
КонецФункции

// Преобразует строку (символ) к регистру строки (символа)-образца.
Функция   ВернутьСтрокуВРегистреПоОбразцу(Знач Стр, Образец) Экспорт
	
	Если НЕ ПустаяСтрока(Образец) Тогда
		Если НРег(Образец) = Образец Тогда
			Возврат НРег(Стр);
		ИначеЕсли ВРег(Образец) = Образец Тогда
			Возврат ВРег(Стр);
		ИначеЕсли ТРег(Образец) = Образец Тогда
			Возврат ТРег(Стр);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Стр;
	
КонецФункции

// Возвращает переданную строку с транслитированными русскими буквами согласно указанной схемы (индексу).
// Все использующиеся схемы должны быть отражены в Параметрах!
//
// Текущие схемы:
// 1 - (Preferred)
//		"Е" -> "E"
//		"Ё" -> "YO"
//		"Й" -> "I" если не предыдущая "И", иначе "ИЙ" как "Y"
//		"Х" -> "KH"
//		"Ц" -> "C"
//		"Щ" -> "SHCH"
//		"Ъ" -> ""
//		"Ь" -> "'"
//		"Э" -> "EH"
//		"Ю" -> "YU"
//		"Я" -> "IA"
// 2 - (ServAss)
//		"Е" -> "E" если не первый символ и не согласная перед ней, иначе "YE"
//		"Ё" -> "YO"
//		"Й" -> "I"
//		"Х" -> "KH"
//		"Ц" -> "TS"
//		"Щ" -> "SHCH"
//		"Ъ" -> ""
//		"Ь" -> ""
//		"Э" -> "E"
//		"Ю" -> "YU"
//		"Я" -> "YA"
// 3 - (Casual)
//		"Е" -> "E"
//		"Ё" -> "YO"
//		"Й" -> "I" если не предыдущая "И", иначе "ИЙ" как "Y"
//		"Х" -> "H"
//		"Ц" -> "C"
//		"Щ" -> "SHCH"
//		"Ъ" -> ""
//		"Ь" -> "'"
//		"Э" -> "E"
//		"Ю" -> "YU"
//		"Я" -> "YA"
// 4 - ГОСТ 16876-71 Правила транслитерации букв кирилловского алфавита буквами латинского алфавита.
//     Переиздание январь 1981 г. с изменениями 1 и 2, утвержденными в декабре 1973 г. и в марте 1980 г.
//		"Е" -> "E"
//		"Ё" -> "JO"
//		"Й" -> "JJ"
//		"Х" -> "KH"
//		"Ц" -> "C"
//		"Щ" -> "SHH"
//		"Ъ" -> "''"
//		"Ь" -> "'"
//		"Э" -> "EH"
//		"Ю" -> "JU"
//		"Я" -> "JA"
// 5 - Система транслитерации Библиотеки конгресса США (Library of Congress Slavic (Russian) Transliteration) и
//     Библиотеки Принстонского университета (Princeton University Library's Russian Transliteration).
//     (объединенная)
//		"Е" -> "E"
//		"Ё" -> "E"
//		"Й" -> "J"
//		"Х" -> "KH"
//		"Ц" -> "TS"
//		"Щ" -> "SHCH"
//		"Ъ" -> "''"
//		"Ь" -> "'"
//		"Э" -> "EH"
//		"Ю" -> "IU"
//		"Я" -> "IA"
// 6 - Система транслитерации Yellow Pages (Traveller's Yellow Pages Transliteration) - TYP.
//     (объединенная)
//		"Е" -> "E"
//		"Ё" -> "E"
//		"Й" -> "Y"
//		"Х" -> "KH"
//		"Ц" -> "TS"
//		"Щ" -> "SHCH"
//		"Ъ" -> ""
//		"Ь" -> ""
//		"Э" -> "E"
//		"Ю" -> "YU"
//		"Я" -> "YA"
//
Функция   ВернутьТранслитированнуюСтроку(Знач Стр, СхемаТранслитерации = 1, СохранятьРегистр = Истина) Экспорт
	
	Если ТипЗнч(СхемаТранслитерации) <> Тип("Число") Или СхемаТранслитерации < 1 Или СхемаТранслитерации > 6 Тогда
 		СхемаТранслитерации = 1;
 	КонецЕсли;
	СтрРез = "";
	
	СтрДл = СтрДлина(Стр);
	Для СтрИнд = 1 По СтрДл Цикл
		
		Симв_ = Сред(Стр, СтрИнд, 1);
		Симв2 = Симв_;
		Симв = ВРег(Симв2);
		
		Если		(Симв = "А") Тогда Симв2 = "A";
		ИначеЕсли	(Симв = "Б") Тогда Симв2 = "B";
		ИначеЕсли	(Симв = "В") Тогда Симв2 = "V";
		ИначеЕсли	(Симв = "Г") Тогда Симв2 = "G";
		ИначеЕсли	(Симв = "Д") Тогда Симв2 = "D";
		ИначеЕсли	(Симв = "Е") Тогда						
						Если СхемаТранслитерации = 2 Тогда
							Если СтрИнд = 1 Тогда
								Симв2 = "Ye";
							Иначе
								СимвПред = ВернутьСимволВРег(Стр, СтрИнд - 1);
								Если (СимвПред = "А") ИЛИ
									 (СимвПред = "Е") ИЛИ
									 (СимвПред = "Ё") ИЛИ
									 (СимвПред = "И") ИЛИ
									 (СимвПред = "Й") ИЛИ //? в оригинальном коде - отсутствовало
									 (СимвПред = "О") ИЛИ
									 (СимвПред = "У") ИЛИ
									 (СимвПред = "Ь") ИЛИ
									 (СимвПред = "Ы") ИЛИ
									 (СимвПред = "Ъ") ИЛИ
									 (СимвПред = "Э") ИЛИ //? в оригинальном коде - отсутствовало
									 (СимвПред = "Ю") ИЛИ
									 (СимвПред = "Я") Тогда
									Симв2 = "Ye";
								Иначе
									Симв2 = "E";
								КонецЕсли;
							КонецЕсли;
						Иначе
							Симв2 = "E";
						КонецЕсли;
		ИначеЕсли	(Симв = "Ё") Тогда Симв2 = ?(СхемаТранслитерации = 4, "Jo", ?(СхемаТранслитерации = 5 Или СхемаТранслитерации = 6, "E", "Yo"));
		ИначеЕсли	(Симв = "Ж") Тогда Симв2 = "Zh";
		ИначеЕсли	(Симв = "З") Тогда Симв2 = "Z";
		ИначеЕсли	(Симв = "И") Тогда Симв2 = "I";
		ИначеЕсли	(Симв = "Й") Тогда
						Если (СхемаТранслитерации = 1) Или (СхемаТранслитерации = 2) Или (СхемаТранслитерации = 3) Тогда
							Симв2 = "I";
						ИначеЕсли СхемаТранслитерации = 6 Тогда
							Симв2 = "Y";
						Иначе
							Симв2 = "J";
						КонецЕсли;
						Если СхемаТранслитерации = 4 Тогда
							Симв2 = Симв2 + "J";
						КонецЕсли;
						Если (СтрИнд > 1) И ((СхемаТранслитерации = 1) Или (СхемаТранслитерации = 3)) Тогда
							СимвПред = ВернутьСимволВРег(Стр, СтрИнд - 1);
							Если (СимвПред = "И") Тогда
								СтрРез = ВернутьОбрезаннуюСтроку(СтрРез, 1);
								Симв2 = "Y";
							КонецЕсли;
						КонецЕсли;
		ИначеЕсли	(Симв = "К") Тогда Симв2 = "K";
		ИначеЕсли	(Симв = "Л") Тогда Симв2 = "L";
		ИначеЕсли	(Симв = "М") Тогда Симв2 = "M";
		ИначеЕсли	(Симв = "Н") Тогда Симв2 = "N";
		ИначеЕсли	(Симв = "О") Тогда Симв2 = "O";
		ИначеЕсли	(Симв = "П") Тогда Симв2 = "P";
		ИначеЕсли	(Симв = "Р") Тогда Симв2 = "R";
		ИначеЕсли	(Симв = "С") Тогда Симв2 = "S";
		ИначеЕсли	(Симв = "Т") Тогда Симв2 = "T";
		ИначеЕсли	(Симв = "У") Тогда Симв2 = "U";
		ИначеЕсли	(Симв = "Ф") Тогда Симв2 = "F";
		ИначеЕсли	(Симв = "Х") Тогда Симв2 = ?(СхемаТранслитерации = 3, "H", "Kh");
		ИначеЕсли	(Симв = "Ц") Тогда Симв2 = ?(СхемаТранслитерации = 2 Или СхемаТранслитерации = 5 Или СхемаТранслитерации = 6, "Ts", "C");
		ИначеЕсли	(Симв = "Ч") Тогда Симв2 = "Ch";
		ИначеЕсли	(Симв = "Ш") Тогда Симв2 = "Sh";
		ИначеЕсли	(Симв = "Щ") Тогда Симв2 = ?(СхемаТранслитерации = 4, "Shh", "Shch");
		ИначеЕсли	(Симв = "Ъ") Тогда Симв2 = ?(СхемаТранслитерации = 4 Или СхемаТранслитерации = 5, "''", "");
		ИначеЕсли	(Симв = "Ы") Тогда Симв2 = "Y";
		ИначеЕсли	(Симв = "Ь") Тогда Симв2 = ?(СхемаТранслитерации = 2 Или СхемаТранслитерации = 6, "", "'");
		ИначеЕсли	(Симв = "Э") Тогда Симв2 = ?(СхемаТранслитерации = 2 Или СхемаТранслитерации = 3 Или СхемаТранслитерации = 6, "E", "Eh");
		ИначеЕсли	(Симв = "Ю") Тогда Симв2 = ?(СхемаТранслитерации = 4, "Ju", ?(СхемаТранслитерации = 5, "Iu", "Yu"));
		ИначеЕсли	(Симв = "Я") Тогда Симв2 = ?(СхемаТранслитерации = 4, "Ja", ?(СхемаТранслитерации = 1 Или СхемаТранслитерации = 5, "Ia", "Ya"));
		КонецЕсли;
		
		СтрРез = СтрРез + ?(СохранятьРегистр, ВернутьСтрокуВРегистреПоОбразцу(Лев(Симв2,1), Симв_) + Сред(Симв2, 2), Симв2);
	
	КонецЦикла;
	
	Возврат СтрРез;
	
КонецФункции

// Функция возвращает массив чисел с номерами позиций пробелов в строке Стр.
// Базируется на функции ОпределитьПозицииПробелов() из УТ
Функция   ПолучитьМассивПозицийПробелов(Знач Стр) Экспорт

	Пробелы = Новый Массив;
	КолПробелов = 0;
	
	Для а = 1 По СтрДлина(Стр) Цикл
		Если Сред(Стр, а, 1) = " " Тогда
			Пробелы.Добавить(а);
			КолПробелов = КолПробелов + 1;		
		КонецЕсли;
	КонецЦикла;

	Возврат Пробелы;
	
КонецФункции

Процедура РазложитьФИО(Знач ФИО, Фамилия, Имя, Отчество) Экспорт
	
	ФИО_ = Строки_КлиентСервер_ат.ВернутьНормализованнуюСтроку(ФИО, Ложь, Истина);
	
	ПозицииПробелов = ПолучитьМассивПозицийПробелов(ФИО_);
	Если ПозицииПробелов.Количество() > 0 Тогда
		Если ПозицииПробелов.Количество() > 1 Тогда
			Фамилия = Сред(ФИО_, 1, (ПозицииПробелов[0] - 1));
			Имя = ВернутьСтрокуСБольшойПервойБуквы(Сред(ФИО_, (ПозицииПробелов[0] + 1), (ПозицииПробелов[1] - ПозицииПробелов[0] - 1)));
			Отчество = ВернутьСтрокуСБольшойПервойБуквы(Сред(ФИО_, (ПозицииПробелов[1] + 1)));
		Иначе
			Фамилия = Сред(ФИО_, 1, (ПозицииПробелов[0] - 1));
			Имя = ВернутьСтрокуСБольшойПервойБуквы(Сред(ФИО_, (ПозицииПробелов[0] + 1)));
			Отчество = "";
		КонецЕсли;
	Иначе
		Фамилия = ФИО_;
		Имя = "";
		Отчество = "";
	КонецЕсли;
	
КонецПроцедуры

// С начала и конца строки удаляются все символы с кодом < 32 (а в случае ТолькоСКраев = Ложь - по всей строке),
// так же по всей строке удаляются все двойные включения пробелов (и Символы.НПП)
Функция   ВернутьНормализованнуюСтроку(Знач Стр, ТолькоСКраев = Истина, ДелатьПервуюБуквуВРег = Ложь) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Стр) Тогда
		
		Возврат СокрЛП(Стр);
		
	КонецЕсли;
	
	Если ТолькоСКраев Тогда
		
		Пока Истина Цикл
			
			Если КодСимвола(Стр, 1) < 32 Тогда
				
				Стр = Прав(Стр, СтрДлина(Стр) - 1);
				
			Иначе
				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Пока Истина Цикл
			
			Если КодСимвола(Стр, СтрДлина(Стр)) < 32 Тогда
				
				Стр = Лев(Стр, СтрДлина(Стр) - 1);
				
			Иначе
				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе	
		
		Для КодСимвола = 0 По 31 Цикл
			
			Стр = СтрЗаменить(Стр, Символ(КодСимвола), "");
			
		КонецЦикла;
		
	КонецЕсли;
	
	Стр = СтрЗаменить(Стр, Символы.НПП, " ");
	
	Пока Найти(Стр, "  ") > 0 Цикл
		
		Стр = СтрЗаменить(Стр, "  ", " ");
		
	КонецЦикла;
	
	Если ДелатьПервуюБуквуВРег Тогда
		
		Стр = ВернутьСтрокуСБольшойПервойБуквы(Стр);
		
	КонецЕсли;

	Возврат Стр;
	
КонецФункции

Функция   ВернутьКакСтроку(Значение) Экспорт
	
	Попытка
		Возврат Строка(Значение);
	Исключение
		Возврат "";
	КонецПопытки;
	
 КонецФункции

Функция   ВернутьТолькоЦифры(Знач Стр, НачПозиция = 1, КонПозиция = 0, Дробь = Истина, СМинусом = Ложь, СоЗнаками = Ложь) Экспорт
	
	ИзвлекаемыеЦифры = "";
	
	Если (НачПозиция = Неопределено) ИЛИ (НачПозиция < 1) Тогда
		НачПозиция_ = 1;
	Иначе
		НачПозиция_ = НачПозиция;
	КонецЕсли;
	
	Если (КонПозиция = Неопределено) ИЛИ (КонПозиция <= 0) ИЛИ (КонПозиция > СтрДлина(Стр)) Тогда
		КонПозиция_ = СтрДлина(Стр);
	Иначе
		КонПозиция_ = КонПозиция;
	КонецЕсли;
	
	Если (НачПозиция_ > КонПозиция_) Тогда
		Возврат "";
	КонецЕсли;
	
	Пока НачПозиция_ <= КонПозиция_ Цикл
		
		Симв = Сред(Стр, НачПозиция_, 1);
		
		Если (КодСимвола(Симв) >= 48 И КодСимвола(Симв) <= 57)
			ИЛИ (Дробь И Симв = ".")
			ИЛИ (СМинусом И ИзвлекаемыеЦифры = "" И Симв = "-")
			ИЛИ (СоЗнаками И (Симв = "+" ИЛИ Симв = "-" ИЛИ Симв = "*" ИЛИ Симв = "/" ИЛИ Симв = "=" ИЛИ Симв = "%"))
			Тогда
			ИзвлекаемыеЦифры = ИзвлекаемыеЦифры + Симв;
		КонецЕсли;
		
		НачПозиция_ = НачПозиция_ + 1;
		
	КонецЦикла;
	
	Возврат ИзвлекаемыеЦифры;
	
КонецФункции

Функция   ЯвляетсяЧислом(Строка) Экспорт
	
	Строка = Строки_КлиентСервер_ат.ВернутьНормализованнуюСтроку(Строка, Ложь);
	Строка = СтрЗаменить(Строка, Символы.НПП, "");
	Строка = СтрЗаменить(Строка, " ", "");
	ЧислоВхожденийТочки = СтрЧислоВхождений(Строка, ".");
	ЧислоВхожденийЗапятой = СтрЧислоВхождений(Строка, ",");
	
	Если (ЧислоВхожденийТочки + ЧислоВхожденийЗапятой > 1)
		ИЛИ ((ЧислоВхожденийТочки + ЧислоВхожденийЗапятой = 1) И (СтрДлина(Строка) = 1)) Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Для Сч = 1 По СтрДлина(Строка) Цикл
		
		Символ = Сред(Строка, Сч, 1);
		
		КодСимвола = КодСимвола(Символ);
		
		Если НЕ ((КодСимвола >= 48 И КодСимвола <= 57)
			ИЛИ (Сч = 1 И КодСимвола = 45)
			ИЛИ КодСимвола = 44
			ИЛИ КодСимвола = 46) Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Оригинал ildarovich (с) http://infostart.ru/profile/28527/
Функция   ПолучитьСиноним(Имя) Экспорт
	
	Ответ = "";
	Состояние = 7;
	ПредыдущийСимвол = "";
	
	Для Индекс = 1 По СтрДлина(Имя) Цикл
		СимволПоИндексу = Сред(Имя, Индекс, 1);
		Состояние = (НРег(СимволПоИндексу) <> СимволПоИндексу) * 4 + Цел(Состояние / 2);
		Флаг = ?(Состояние = 2, НРег(ПредыдущийСимвол), ?(Индекс = 2, ВРег(ПредыдущийСимвол), ПредыдущийСимвол)) + ?(Состояние = 4 ИЛИ Состояние = 5, " ", "");
		Ответ = Ответ + ?(Флаг = "_ ", " ", Флаг);
		ПредыдущийСимвол = СимволПоИндексу;
	КонецЦикла;
	
	Возврат Ответ + ПредыдущийСимвол;
	
КонецФункции

// Функция возвращает "номер тикета" - основанное на номере и дате документа удобно форматированное число.
// Есть два режима генерации номера - с использованием трёх последних цифр номера документа и генерацией восьмизначного
// (четыре пары) номера тикета (Режим2х4 = Истина, по умолчанию) или с использованием четырёх и созданием номера из трёх
// триплетов. Алгоритм генерации позволяет по номеру тикета корректно восстановить ДатаДок и НомерДок (если их, конечно, не
// более 999 для первого режима и 9999 для второго, за день) при этом сам тикет достаточно компактен.
// Контроль на корректность номера документа не осуществляется.
Функция   ПолучитьНомерТикета(НомерДок, ДатаДок, Режим4по2 = Истина) Экспорт

	НомерДокСтр = Строка(НомерДок);
	//тест
	//НомерДокСтр = Строка("000012458");
	//ДатаДок = Дата(2013, 10, 19);
	//Режим4по2 = Ложь;
	
	ФорматированнаяДата = Формат(ДатаДок, "ДФ=ггкММдд");
	ПоследняяЦифраГода = Сред(ФорматированнаяДата, 2, 1);
	Квартал = Сред(ФорматированнаяДата, 3, 1);
	СуммаЦифрМесяца = Строка(Число(Сред(ФорматированнаяДата, 4, 1)) + Число(Сред(ФорматированнаяДата, 5, 1)));
	НомерНеделиТекущегоМесяца = НеделяГода(ДатаДок) - НеделяГода(НачалоМесяца(ДатаДок)) + 1;
	ПоследняяЦифраСуммыЦифрДняМесяца = Прав(Строка(Число(Сред(ФорматированнаяДата, 6, 1)) + Число(Сред(ФорматированнаяДата, 7, 1))), 1);
	
	ДлинаНомерДок = СтрДлина(НомерДокСтр);
	//Если Режим4по2 Тогда
	//	КоличествоСимволовНомера = 3;
	//Иначе
	//	КоличествоСимволовНомера = 4;
	//КонецЕсли;
	//НомерДокСтр = Прав(НомерДок, КоличествоСимволовНомера);
	//НомерДокСКонца = "";
	//Пока КоличествоСимволовНомера > 0 Цикл
	//	НомерДокСКонца = НомерДокСКонца + Сред(НомерДокСтр, КоличествоСимволовНомера , 1);
	//	КоличествоСимволовНомера = КоличествоСимволовНомера - 1;
	//КонецЦикла;
	
	Если Режим4по2 Тогда
		Возврат
		//тест
		//Сообщить(
			Сред(НомерДокСтр, ДлинаНомерДок, 1) + ПоследняяЦифраГода + "-"
			+ Сред(НомерДокСтр, ДлинаНомерДок - 1, 1) + Квартал + "-"
			+ Сред(НомерДокСтр, ДлинаНомерДок - 2, 1) + СуммаЦифрМесяца + "-"
			+ НомерНеделиТекущегоМесяца + ПоследняяЦифраСуммыЦифрДняМесяца
		//тест
		//)
		;
	Иначе
		Возврат
		//тест
		//Сообщить(
			Сред(НомерДокСтр, ДлинаНомерДок, 1) + ПоследняяЦифраГода + Квартал + "-"
			+ Сред(НомерДокСтр, ДлинаНомерДок - 1, 1) + Сред(НомерДокСтр, ДлинаНомерДок - 2, 1) + СуммаЦифрМесяца + "-"
			+ Сред(НомерДокСтр, ДлинаНомерДок - 3, 1) + НомерНеделиТекущегоМесяца + ПоследняяЦифраСуммыЦифрДняМесяца
		//тест
		//)
		;
	КонецЕсли;
	
КонецФункции

// Параметр1 - Разделитель (для чисел и коллекций)
// Параметр2 - ИспользоватьПредставление (только для коллекций)
// Параметр3 - ИгнорироватьПустыеЗначения (только для коллекций)
Функция   ПреобразоватьВСтроку(Значение, Параметр1 = Неопределено, Параметр2 = Ложь, Параметр3 = Истина) Экспорт // oldname - ВСтроку

	Если ТипЗнч(Значение) = Тип("Число") Тогда
		
		Если Параметр1 = Неопределено Тогда
			Параметр1 = ".";
		КонецЕсли;
		Результат = Формат(Значение, "ЧГ=; ЧРД=.");
		Возврат ?(Результат = "", "0", Результат);
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда
		
		Возврат Формат(Значение, "БЛ=Ложь; БИ=Истина");
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Массив")
			Или ТипЗнч(Значение) = Тип("Структура")
			Или ТипЗнч(Значение) = Тип("Соответствие")
			Или ТипЗнч(Значение) = Тип("СписокЗначений")
			#Если ТолстыйКлиентОбычноеПриложение Или Сервер Тогда
			Или ТипЗнч(Значение) = Тип("ТаблицаЗначений")
			Или ТипЗнч(Значение) = Тип("СтрокаТаблицыЗначений")
			#КонецЕсли
			Или ТипЗнч(Значение) = Тип("ФиксированныйМассив") Тогда

		Если Параметр1 = Неопределено Тогда
			Параметр1 = ", ";
		КонецЕсли;
		
		ЭтоСтруктура = (ТипЗнч(Значение) = Тип("Структура"));
		Результат = "";
		Если ЭтоСтруктура Тогда // в целях быстродействия не будем делать через ?(.. в одну строку
			Если Параметр2 Тогда
				Для Каждого Элемент Из Значение Цикл
					Если Не Параметр3 Или (Параметр3 И Не ПустаяСтрока(СокрЛП(Элемент.Значение))) Тогда
						Результат = Результат + СокрЛП(Элемент.Значение) + Параметр1;
					КонецЕсли;
				КонецЦикла;
			Иначе
				Для Каждого Элемент Из Значение Цикл
					Если Не Параметр3 Или (Параметр3 И Не ПустаяСтрока(СокрЛП(Элемент.Значение))) Тогда
						Результат = Результат + СокрЛП(Элемент.Ключ) + ": " + СокрЛП(Элемент.Значение) + Параметр1;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		Иначе
			Если Параметр2 Тогда
				Для Каждого Элемент Из Значение Цикл
					Если Не Параметр3 Или (Параметр3 И Не ПустаяСтрока(СокрЛП(Элемент.Представление))) Тогда
						Результат = Результат + СокрЛП(Элемент.Представление) + Параметр1;
					КонецЕсли;
				КонецЦикла;
			Иначе
				Для Каждого Элемент Из Значение Цикл
					Если Не Параметр3 Или (Параметр3 И Не ПустаяСтрока(СокрЛП(Элемент))) Тогда
						Результат = Результат + СокрЛП(Элемент) + Параметр1;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Лев(Результат, СтрДлина(Результат) - СтрДлина(Параметр1));
	Иначе
		Возврат Строка(Значение);
	КонецЕсли;
	
КонецФункции // ПреобразоватьВСтроку

Функция   ПолучитьСтрУИдПоНавСсылке(НавСсылка) Экспорт
	
	ПозицияРефа = СтрНайти(НавСсылка, "?ref=");
	
	Если (ПозицияРефа > 0) И (ПозицияРефа + 5 + 32 - 1 <= СтрДлина(НавСсылка)) Тогда
		Возврат ПолучитьСтрУИдПоНавигационномуРефу(Сред(НавСсылка, ПозицияРефа + 5));
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

Функция   ПолучитьСтрУИдПоНавигационномуРефу(НавРеф) Экспорт
	
	//Берём правые 32 символа и переставляем их местами по формуле:
	//последние 8 символов - 4 символа, начиная с 21-го - 4 символа, начиная с 17-го - 4 первых символа - 12 символов, начиная с 5-го
	//или номерами символов 25 26 27 28 29 30 31 32 - 21 22 23 24 - 17 18 19 20 - 1 2 3 4 - 5 6 7 8 9 10 11 12 13 14 15 16.
	//Между группами символов ставим дефис на позициях 9, 14, 19, 24.
	//
	//	e1cib/data/Документ.Событие?ref=b9cda0369ff2debd11e8f6f33ccb99ff
	
	Возврат ВРег(Прав(НавРеф, 8)
	+ "-" + Сред(НавРеф, 21, 4)
	+ "-" + Сред(НавРеф, 17, 4)
	+ "-" + Лев(НавРеф, 4)
	+ "-" + Сред(НавРеф, 5, 12));

КонецФункции

Функция   ПолучитьВнешнююНавСсылкуПоУИд(УИд, ИмяСервераИлиАдресИБ, ИмяИБ = "", МетаИмяОбъекта) Экспорт
	
	//СтандартныйПрефикс = ПолучитьНавигационнуюСсылкуИнформационнойБазы() + "/";
	//ЭтоВебКлиент = Найти(СтандартныйПрефикс, "http://") > 0;
	//Если ЭтоВебКлиент Тогда
	//	КодЛокализации = ТекущийКодЛокализации();
	//	СтандартныйПрефикс = СтандартныйПрефикс + КодЛокализации + "/";
	//КонецЕсли;
	
	НавСсылка = "e1c://server/" + ?(ИмяИБ = "", ИмяСервераИлиАдресИБ, ИмяСервераИлиАдресИБ + "/" + ИмяИБ) + "#e1cib/data/" + МетаИмяОбъекта + "?ref="
		+ НРег(Сред(УИд, 20, 4)
		+ Прав(УИд, 12)
		+ Сред(УИд, 15, 4)
		+ Сред(УИд, 10, 4)
		+ Лев(УИд, 8));
	
	//Попытка
	//	НачатьЗапускПриложения(Новый ОписаниеОповещения, НавСсылка);
	//Исключение
	//КонецПопытки;
	
КонецФункции
