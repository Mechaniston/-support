
// Проводит инициализацию библиотеки проверки орфографии.
// При этом распаковываются все необходимые файлы.
//
// Возвращаемое значение:
//  Булево - Истина в случае успешной инициализации и ложь если возникли ошибки.
// 
Функция   ИнициализироватьПроверкуОрфографии() Экспорт
	
	КаталогФайловПроверкиОрфографии = КаталогВременныхФайлов() + ПолучитьИмяКатологаФайловПроверки();
	ПутьККомпоненте = КаталогФайловПроверкиОрфографии + "\AddIn.hunspell.dll";
	
	Файл = Новый Файл(КаталогФайловПроверкиОрфографии);
	Компонента = Новый Файл(ПутьККомпоненте);
	
	//+ Проверка наличия компаненты
	
	Если НЕ Файл.Существует() ИЛИ НЕ Компонента.Существует() Тогда
		
		ОбщегоНазначения_ВызовСервера_ат.ВернутьОбщийМакет("ПроверкаОрфографии_ат").Записать(КаталогВременныхФайлов() + "Spellchecking.zip");
		
		Zip = Новый ЧтениеZipФайла(КаталогВременныхФайлов() + "Spellchecking.zip");
		Zip.ИзвлечьВсе(КаталогФайловПроверкиОрфографии); 
		
		УдалитьФайлы(КаталогВременныхФайлов() + "Spellchecking.zip");
		
	КонецЕсли;
	
	//- Проверка наличия компаненты
	
	//+ Подключение компоненты
	
	Если НЕ ПодключитьВнешнююКомпоненту(ПутьККомпоненте, "Hunspell", ТипВнешнейКомпоненты.Native) Тогда
	
		Возврат Ложь;
		
	КонецЕсли;
	
	//- Подключение компоненты
	
	// Инициализируем класс для проверки орфографии
	Попытка
		
		КомпонентаПроверкиОрфографии = Новый("AddIn.Hunspell.HunspellClass");
		
	Исключение
		
		Сообщить(ОписаниеОшибки());
		
		Возврат Ложь;
		
	КонецПопытки;
	
	//+ Инициализация словарей
	
	Попытка
		
		ПутьКСловарям = КаталогФайловПроверкиОрфографии + "\Dictionaries\";
		
		// Основной словарь
		КомпонентаПроверкиОрфографии.ИнициализироватьСловарь(ПутьКСловарям + "en-ru.aff", ПутьКСловарям + "en-ru.dic");
		
		// Дополнительные словари
		КомпонентаПроверкиОрфографии.ПодключитьДополнительныйСловарь(ПутьКСловарям + "fr_FR.dic");
		КомпонентаПроверкиОрфографии.ПодключитьДополнительныйСловарь(ПутьКСловарям + "it_IT.dic");
		КомпонентаПроверкиОрфографии.ПодключитьДополнительныйСловарь(ПутьКСловарям + "de_DE_comb.dic");
		КомпонентаПроверкиОрфографии.ПодключитьДополнительныйСловарь(ПутьКСловарям + "es_ES.dic");
		КомпонентаПроверкиОрфографии.ПодключитьДополнительныйСловарь(ПутьКСловарям + "finnish.dic");
		
	Исключение
		
		Сообщить(ОписаниеОшибки());
		
		Возврат Ложь;
		
	КонецПопытки;
	
	//- Инициализация словарей
	
	Возврат Истина;
	
КонецФункции

// Возвращает имя каталога файлов проверки орфографии.
//
// Возвращаемое значение:
//  Строка
// 
Функция   ПолучитьИмяКатологаФайловПроверки() Экспорт
	
	Возврат "Spellchecking_1_0_0_4";
	
КонецФункции

// Проверяет наличие слова в словаре.
//
// Параметры:
//	Слово - Строка - Слово, поиск которого будет осуществлён.
//
// Возвращаемое значение:
//  Булево - Истина если слово найжено и ложь, если не найдено.
// 
Функция   СловоЕстьВСловаре(Слово) Экспорт
	
	#Если НЕ ВебКлиент Тогда
	
	Если КомпонентаПроверкиОрфографии <> Неопределено ИЛИ ИнициализироватьПроверкуОрфографии() Тогда
		
		Возврат КомпонентаПроверкиОрфографии.СловоЕстьВСловаре(Слово);
		
	Иначе 
		
		Возврат Истина;
		
	КонецЕсли;
	
	#КонецЕсли
	
КонецФункции

// Возвращает варианты замены для слова.
//
// Параметры:
//	Слово - Строка - Слово, для которого будут подобраны варианты замены.
//
// Возвращаемое значение:
//  Массив - Массив состоящий из строк вариантов замены.
// 
Функция   ПредложитьВариантыЗамены(Слово) Экспорт
	
	Если КомпонентаПроверкиОрфографии <> Неопределено ИЛИ ИнициализироватьПроверкуОрфографии() Тогда
		
		МассивВариантовЗамены = Системный_КлиентСервер_Переопределяемый_ат.РазложитьСтрокуВМассивПодстрок(
			КомпонентаПроверкиОрфографии.ПредложитьВариантыЗамены(Слово), ";");
		
		// Удаление пустые значения
		ИндексПустого = МассивВариантовЗамены.Найти("");
		
		Пока ИндексПустого <> Неопределено Цикл
			
			МассивВариантовЗамены.Удалить(ИндексПустого);
			ИндексПустого = МассивВариантовЗамены.Найти("");
			
		КонецЦикла;

		Возврат МассивВариантовЗамены; 
		
	Иначе	
		
		Возврат Новый Массив;
		
	КонецЕсли;
	
КонецФункции

// Проверяет переданный текст.
//
// Параметры:
//	Строка - Строка - Текст для проверки.
//
// Возвращаемое значение:
//  Строка - Разделенные знаком точки с запятой слова, которые не были найдены в словаре.
// 
Функция   ПроверитьТекст(Строка) Экспорт
	
	Если КомпонентаПроверкиОрфографии <> Неопределено ИЛИ ИнициализироватьПроверкуОрфографии() Тогда
		
		Возврат КомпонентаПроверкиОрфографии.ПроверитьПравописаниеТекста(Строка);
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Выделяет в тексте слова, которые не были найдены в словаре.
//
// Параметры:
//	Документ - ПолеHTMLДокумента - элемент управления типа ПолеHTMLДокумента, текст которого необходимо проверить.
//	КоличествоВыделяемыхОшибок - Число, Неопределено - количесво не найденых в словаре слов, которые будут подсвечены (если значение "-1" - без ограничения).
//	ПредставлениеПоля - Строка - Представление поля, которое будет использовано в сообщении пользователю о количестве подсвеченных слов.
//
Процедура ПроверитьТекстВПолеHTMLДокумента(Документ, КоличествоВыделяемыхОшибок = 100, ПредставлениеПоля = "") Экспорт
	
	#Если НЕ Вебклиент Тогда
	
	RegExp = РегулярныеВыражения_КлиентСервер_ат.СоздатьОбъектРегулярныхВыражений();
	
	RegExp.Pattern = "["+символ(8203)+"¡¿«»\s""'!;:,\[\]\\\^\$\.\|\?\*\+\(\)\{\}&=<>]";
	ПроверяемыйТекст = RegExp.Replace(Документ.body.innerText, " ");
	
	МассивНеопознанныхСлов = Системный_КлиентСервер_Переопределяемый_ат.РазложитьСтрокуВМассивПодстрок(ПроверитьТекст(ПроверяемыйТекст), ";");
	МассивНеопознанныхСлов =  ПроверкаОрфографии_ВызовСервера_ат.ВернутьМассивСловНеСодержащихсяВПроизвольномСловаре(МассивНеопознанныхСлов);
	
	Сч = 0;
	Текст = УдалитьИзТекстаHTMLТэгиВыделения(Документ.body.innerHTML, RegExp);
	
	Для Каждого Слово Из МассивНеопознанныхСлов Цикл
		
		Если Сч = КоличествоВыделяемыхОшибок Тогда
			
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = ?(ПредставлениеПоля = "", "Выделены ", "В поле """ + ПредставлениеПоля + """ выделены ") +
				"первые " + КоличествоВыделяемыхОшибок + " найденых ошибок.";
			Сообщение.Сообщить(); 
			
			Прервать;
			
		КонецЕсли;
		
		Если Слово = "" Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		RegExp.Pattern = "([\[\]\\\^\$\.\|\?\*\+\(\)\{\}])";
		Слово = RegExp.Replace(Слово, "\$1");
		
		RegExp.Pattern = "([¡¿«»\s""'!;:,\[\]\\\^\$\.\|\?\*\+\(\)\{\}&=<>]|^)(" + Слово + ")([¡¿«»\s""'!;:,\[\]\\\^\$\.\|\?\*\+\(\)\{\}&=<>]|$)";	
		
		Текст = RegExp.Replace(Текст, "$1<FONT id=red_marker color=#ff0000>$2</FONT>$3");
		
		Сч = Сч + 1;
		
	КонецЦикла;
	
	Документ.body.innerHTML = Текст;
	
	#КонецЕсли
	
КонецПроцедуры

// Удаляет из текста HTML тэги выделения красным.
//
// Параметры:
//	Текст - Строка - Текст HTML, который необходимо очистить тэгов.
//	RegExp - COMОбъект - Объект для работы с регулярными выражениями. Если Неопределено - будет создан.
//
// Возвращаемое значение:
//  Строка - Очищенная от тегов строка.
//
Функция   УдалитьИзТекстаHTMLТэгиВыделения(Текст, RegExp = Неопределено) Экспорт
	
	Текст = СтрЗаменить(Текст, "%3C", "<");
	Текст = СтрЗаменить(Текст, "%3E", ">");
	Текст = СтрЗаменить(Текст, "%20", " ");
	
	Если RegExp = Неопределено Тогда
		
		Результат = РегулярныеВыражения_КлиентСервер_ат.Заменить(Текст, "<FONT[^>]*id=red_marker color=(#ff0000)>([^<]*)</FONT>", "$2", Ложь);
		
	Иначе
		
		Global = RegExp.Global;	
		IgnoreCase = RegExp.IgnoreCase;
		MultiLine = RegExp.MultiLine;
		Pattern = RegExp.Pattern;
		
		RegExp.Global = Истина;	
		RegExp.IgnoreCase = Ложь;
		RegExp.MultiLine = Истина;
		RegExp.Pattern = "<FONT[^>]*id=red_marker color=(#ff0000)>([^<]*)</FONT>";
		
		Результат = RegExp.Replace(Текст, "$2");
		
		RegExp.Global = Global;	
		RegExp.IgnoreCase = IgnoreCase;
		RegExp.MultiLine = MultiLine;
		RegExp.Pattern = Pattern;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

