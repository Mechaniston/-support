
&НаКлиенте
функция КодBase64(Элемент) Экспорт
	
//	Требуется наличие установленного Перла!
	ПутьКом = "D:\1c\";
	СтрКом = "Perl " + ПутьКом + "Base64.pl -data=""" + Элемент + " ";
//	
	возврат(Запустить(СтрКом));
  
	
КонецФункции

&НаКлиенте
Функция   DecodeBase64(Элемент) Экспорт
	
//	Требуется наличие установленного Перла!
	ПутьКом = "D:\1c\";
	СтрКом = "Perl " + ПутьКом + "DeBase64.pl -data=""" + Элемент + " ";
//	
	возврат(Запустить(СтрКом));
  
	
КонецФункции

&НаКлиенте
Функция   Info() Экспорт
	
		Парам = " -a";
		//  Парам = " -a"; выводит все Контейнеры_ат, в том числе отключенные
		//Парам = ""; выводит только рабочие
		
		//ФорматВывода = " -o veid,status,name,hostname,ip,diskspace,cpus,vprvmem,vprvmem.b,numsessions";
		ФорматВывода = " -o veid,hostname,ip,status,numproc,numproc.b,numsessions,numsessions.b,diskspace,diskspace.h,cpus,vprvmem,vprvmem.b,gateway,nameserver";
		// в формате вывода перечисленны не все столбцы
		// это сделано потому, что некоторые из этих столбцов в ячейках содержат множества значений
		// которые в данном запросе невозможно распарсить
			
		СтрКом = "vzlist " + Парам + ФорматВывода;
		возврат(Запустить(СтрКом));
		
		
	КонецФункции

&НаКлиенте
Функция   Запустить(СтрокаКоманды) Экспорт
	
    Шелл = Новый COMОбъект("WScript.Shell");
    //запускаем консоль, далее очищаем экран и через конвеер 
    //выводим содержимое каталога windows (через гл. переменную)
  	//      СтрокаЗапуска = "cmd.exe /C cls|dir %windir%";
	СтрокаЗапуска = "cmd.exe /C cls|" + СтрокаКоманды;

    //можно вывести информацию системного окружения
    //СтрокаЗапуска = "cmd.exe /C cls|set";
    
    Вывод = Шелл.Exec(СтрокаЗапуска);
    СтрокиДанных = "";
    //пока не достигнут конец потока
    Пока Не Вывод.StdOut.AtEndOfStream Цикл
            СтрокиДанных = СтрокиДанных + Вывод.StdOut.Read(1);
    КонецЦикла;
//      	Элементы.СтрокаВывода.ВыделенныйТекст = СтрокаМаршрутов;
//			Сообщить(СтрокаМаршрутов);
	возврат(СтрокиДанных);
	
КонецФункции

&НаКлиенте
Процедура ZV() Экспорт
    // получаем hostname текущей машины
	nameHost = СокрЛП(РаботаССерверамиСлужебный_ат.Запустить("echo %COMPUTERNAME%"));
	//Использую команду СокрЛП т.к. возвращается несколько строк и/или строи с пробелами
	
	// запрошиваем данные о VZ контейнерах! 
	Данные = РаботаССерверамиСлужебный_ат.Info();
	
	// обрабатываем полученные данные
	РаботаССерверами_ат.VZНаСервере(Данные,nameHost);
КонецПроцедуры

&НаКлиенте
Процедура Virtuozzo() Экспорт
			РаботаССерверамиСлужебный_ат.ZV();
			ЗавершитьРаботуСистемы(ложь);
КонецПроцедуры

Функция   РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель) Экспорт
//        разделитель. Разделитель может иметь любую длину. 
//        Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//        считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//        игнорируются.
//        Например, 
//        РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//        три из которых - пустые строки, а 
//        РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//    Параметры: 
//        Стр -             строка, которую необходимо разложить на подстроки. 
//                        Параметр передается по значению.
//        Разделитель -     строка-разделитель, по умолчанию - запятая.
//
//
//    Возвращаемое значение:
//        массив значений, элементы которого - подстроки
//
   
    МассивСтрок = Новый Массив();
    Если Разделитель = " " Тогда
        Стр = СокрЛП(Стр);
        Пока 1=1 Цикл
            Поз = Найти(Стр,Разделитель);
            Если Поз=0 Тогда
                МассивСтрок.Добавить(Стр);
                Возврат МассивСтрок;
            КонецЕсли;
            МассивСтрок.Добавить(Лев(Стр,Поз-1));
            Стр = СокрЛ(Сред(Стр,Поз));
        КонецЦикла;
    Иначе
        ДлинаРазделителя = СтрДлина(Разделитель);
        Пока 1=1 Цикл
            Поз = Найти(Стр,Разделитель);
            Если Поз=0 Тогда
                МассивСтрок.Добавить(Стр);
                Возврат МассивСтрок;
            КонецЕсли;
            МассивСтрок.Добавить(Лев(Стр,Поз-1));
            Стр = Сред(Стр,Поз+ДлинаРазделителя);
        КонецЦикла;
    КонецЕсли;
    
КонецФункции 

&НаСервере	
Функция   Парсинг(ВходящиеДанные, ИтоговаяТаблицаЗначений) Экспорт 
		
	КоличествоКолонок  =16;    //!!!HARDCODED
	КоличествоСлов = КоличествоКолонок;
	Индекс = 0;
	
	//ИтоговаяТаблицаЗначений = Новый ТаблицаЗначений;
	Пока Индекс < КоличествоКолонок Цикл
		ИтоговаяТаблицаЗначений.Колонки.Добавить();
		Индекс = Индекс + 1;
	КонецЦикла;
	//сообщить(nameHost);
	НаборСтрок = РазложитьСтрокуВМассивПодстрок(ВходящиеДанные, Символы.ПС);
	Для каждого стр из НаборСтрок цикл
				
		
		НоваяСтрока = ИтоговаяТаблицаЗначений.Добавить();
		НаборСлов = РазложитьСтрокуВМассивПодстрок(стр, " ");
		//НаборСлов = РазложитьСтрокуВМассивПодстрок(стр, Символы.Таб);

	//	сообщить(НаборСлов);
	//	
			 Индекс2 =0;
		Пока Индекс2 < НаборСлов.Количество() Цикл
			
			НоваяСтрока[Индекс2] = НаборСлов[Индекс2];	
			Индекс2 = Индекс2 + 1;
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат  ИтоговаяТаблицаЗначений;
		
КонецФункции

&НаКлиенте
Процедура ОбработкаВыбораПараметровЖелеза(Элемент, ДанныеВыбора, СтандартнаяОбработка, группа) Экспорт

	СтандартнаяОбработка = Ложь;
	ПараметрыОтбора = Новый Структура("Отбор",РаботаССерверами_ат.ПолучитьПараметрыЖелеза(группа));
	Форма=ПолучитьФорму("Справочник.ПараметрыОборудования_ат.ФормаВыбора",ПараметрыОтбора,Элемент);
	// Нужно чтобы выводилось без групп
	Форма.Элементы.Список.Отображение = ОтображениеТаблицы.Список;
	Форма.Открыть();

КонецПроцедуры
		
&НаСервере		
Функция   РаботаСЖелезнымСервером(Команда) Экспорт
	
	Шелл = Новый COMОбъект("WScript.Shell");	
	Вывод = Шелл.Exec(Команда);	
	СтрокиДанных = "";
    //пока не достигнут конец потока
    Пока Не Вывод.StdOut.AtEndOfStream Цикл
            СтрокиДанных = СтрокиДанных + Вывод.StdOut.Read(1);
    КонецЦикла;
//	Элементы.СтрокаВывода.ВыделенныйТекст = СтрокаМаршрутов;
//	Сообщить(СтрокаМаршрутов);
	возврат(СтрокиДанных);

КонецФункции

// возвращает числовое значение указанного IP
//
// Параметры:
//  IP  - строка - на вход подается IP с разделением групп точками
//				Пример: "127.0.0.1".
// Возвращаемое значение:
//   число   - после преобразования возвращается число без пробелов и разделителей
//
Функция   ПреобразоватьIPВЧисло(IP, IPv4 = Истина)  Экспорт
	
	НаборГрупп = РазложитьСтрокуВМассивПодстрок(СтрЗаменить(IP," ", ""), ".");
	//index = 0;
	//Группа = Новый ТаблицаЗначений;
	//НоваяГруппа = Группа.Добавить();  
	
	//Пока index < НаборГрупп.Количество() цикл
	//	НоваяГруппа =  Число(НаборГрупп[index]);
	//	index = index+1;
	//КонецЦикла;
	Если IPv4 = Истина тогда
		//Если Группа.Количество() = 4 тогда
		//	Число =  Группа[0]*256*256*256 + Группа[1]*256*256 + Группа[2]*256 + Группа[3];
		
		Если НаборГрупп.Количество() = 4 тогда
			Число =  НаборГрупп[0]*256*256*256 + НаборГрупп[1]*256*256 + НаборГрупп[2]*256 + НаборГрупп[3];

			Возврат Число;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции // ПреобразоватьIPВЧисло()

// <Описание функции>
//
// Параметры:
//  ЧисловоеЗначениеIP  - число - Числовое значение IP адреса
//
//	Разделитель  - текст - символы резделения групп
//
// Возвращаемое значение:
//   Текст   - текстовое значение IP  с Группами разделенными символом разделителем
//
Функция   ПреобразоватьЧислоВТекстовыйIP( ЧисловоеЗначениеIP, Разделитель = ".") Экспорт
	Если  ТипЗнч(ЧисловоеЗначениеIP) = Тип("Число") тогда
 	A = Цел(ЧисловоеЗначениеIP/256/256/256);
   	B = Цел((ЧисловоеЗначениеIP-A*256*256*256)/256/256);
   	C = Цел((ЧисловоеЗначениеIP-A*256*256*256-B*256*256)/256);
   	D = Цел(ЧисловоеЗначениеIP-A*256*256*256-B*256*256-C*256);

	Возврат ""+ A+Разделитель+B+Разделитель + C +Разделитель +D; 	
Иначе
	Возврат неопределено;
	
	КонецЕсли;
КонецФункции // ПреобразоватьЧислоВIP()

// <Описание функции>
//
// Параметры:
//  IP  - число - Числовое значение IP адреса
//  Подсеть  - число - Числовое значение IP адреса сети.
//  МаскаСети - Число - Числовое Значение маски сети.
// Возвращаемое значение:
//   <Тип.Вид>   - <описание возвращаемого значения>
//
Функция   ПроверкаПринадлежностиIPУказаннойПодсети(ИП, Подсеть, МаскаСети)
	

КонецФункции // ПроверкаПринадлежностиIPУказаннойПодсети()

&НаСервере	
Функция   ПереводимЧислоВБиты(Знач число, Битность = 32)   Экспорт
	 	
	Биты = "";
	Для й = 1 По Битность Цикл
		Бит = Число % 2;
		Число = Цел(Число/2);
		// Бит = Цел(Число / pow(2, Битность - й)) % 2;
		Биты = Строка(бит) + Биты;
	КонецЦикла;
	Возврат Биты;
	
КонецФункции

Функция   _AND(Знач A, Знач B, L = 8)     экспорт
    R = 0;
    Для I = 1 по L Цикл
        M = POW(2, L - I);
        R = R + M * ?((A >= M) AND (B >= M), 1, 0);
        A = ?(A < M, A, A - M);
        B = ?(B < M, B, B - M);
    КонецЦикла;
    Возврат R;
КонецФункции
